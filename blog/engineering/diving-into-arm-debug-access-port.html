<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="icon" href="/assets/favicon/favicon.png" type="image/png" /><link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png" /><link rel="stylesheet" href="/assets/css/libs.bundle.css?v=4" /><link rel="stylesheet" href="/assets/css/theme.bundle.css?v=4" /><title>A Deep Dive into the ARM Debug Access Port | PlatformIO Labs</title><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="A Deep Dive into the ARM Debug Access Port" /><meta name="author" content="Alex Kavalchuk" /><meta property="og:locale" content="en_US" /><meta name="description" content="Exploring the Architecture and Capabilities of the ARM Debug Access Port for Embedded System Debugging" /><meta property="og:description" content="Exploring the Architecture and Capabilities of the ARM Debug Access Port for Embedded System Debugging" /><link rel="canonical" href="https://piolabs.com/blog/engineering/diving-into-arm-debug-access-port.html" /><meta property="og:url" content="https://piolabs.com/blog/engineering/diving-into-arm-debug-access-port.html" /><meta property="og:site_name" content="PlatformIO Labs" /><meta property="og:image" content="https://piolabs.com/assets/posts/2023-05-09-diving-into-arm-debug-access-port/title.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-09T00:00:00+03:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://piolabs.com/assets/posts/2023-05-09-diving-into-arm-debug-access-port/title.jpg" /><meta property="twitter:title" content="A Deep Dive into the ARM Debug Access Port" /><meta name="twitter:site" content="@PlatformIO_Org" /><meta name="twitter:creator" content="@Alex Kavalchuk" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alex Kavalchuk"},"dateModified":"2023-05-09T00:00:00+03:00","datePublished":"2023-05-09T00:00:00+03:00","description":"Exploring the Architecture and Capabilities of the ARM Debug Access Port for Embedded System Debugging","headline":"A Deep Dive into the ARM Debug Access Port","image":"https://piolabs.com/assets/posts/2023-05-09-diving-into-arm-debug-access-port/title.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://piolabs.com/blog/engineering/diving-into-arm-debug-access-port.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://piolabs.com/assets/img/platformio-logo-icon.png"},"name":"Alex Kavalchuk"},"url":"https://piolabs.com/blog/engineering/diving-into-arm-debug-access-port.html"}</script><link type="application/atom+xml" rel="alternate" href="https://piolabs.com/feed.xml" title="PlatformIO Labs" /></head><body><nav class="navbar navbar-expand-lg navbar-light"><div class="container"> <a class="navbar-brand" href="/"> <img src="/assets/img/platformio-labs-logo-horizontal.png" class="navbar-brand-img" alt="PlatformIO Labs"> </a> <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button><div class="collapse navbar-collapse" id="navbarCollapse"> <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"> <i class="fe fe-x"></i> </button><ul class="navbar-nav ms-auto"><li class="nav-item"> <a class="nav-link" href="/">Home</a></li><li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" id="navbarTechnology" data-bs-toggle="dropdown" href="#" aria-haspopup="true" aria-expanded="false"> Technology </a><div class="dropdown-menu dropdown-menu-xl p-0" aria-labelledby="navbarTechnology"><div class="row gx-0"><div class="col-12 col-lg-6"><div class="dropdown-img-start"><h3 class="text-white"> In-house IDE or Next-Gen?</h3><p class="fs-sm text-white text-center"> See comparison of the existing IDE solutions in the market</p><a href="/blog/insights/next-generation-ide-for-decades.html" class="btn btn-sm btn-white shadow-dark fonFt-size-sm"> Learn More </a></div></div><div class="col-12 col-lg-6 dropdown-body"><div class="list-group list-group-flush"> <a class="list-group-item" href="/technology/next-generation-ide-framework.html"><div class="icon icon-sm text-primary-desat"> <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z" /><path d="M17.272 8.685a1 1 0 111.456-1.37l4 4.25a1 1 0 010 1.37l-4 4.25a1 1 0 01-1.456-1.37l3.355-3.565-3.355-3.565zm-10.544 0L3.373 12.25l3.355 3.565a1 1 0 01-1.456 1.37l-4-4.25a1 1 0 010-1.37l4-4.25a1 1 0 011.456 1.37z" fill="#335EEA" /> <rect fill="#335EEA" opacity=".3" transform="rotate(15 12 12)" x="11" y="4" width="2" height="16" rx="1" /> </g> </svg></div><div class="ms-4"><h6 class="text-uppercase text-primary-desat mb-0"> Next-Gen IDE Framework</h6><p class="fs-sm text-gray-700 mb-0"> Flexible, free IDE for everyone</p></div></a> <a class="list-group-item" href="/technology/modern-ui-toolkit.html"><div class="icon icon-sm text-success"> <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z" /><path d="M5.5 4h4A1.5 1.5 0 0111 5.5v1A1.5 1.5 0 019.5 8h-4A1.5 1.5 0 014 6.5v-1A1.5 1.5 0 015.5 4zm9 12h4a1.5 1.5 0 011.5 1.5v1a1.5 1.5 0 01-1.5 1.5h-4a1.5 1.5 0 01-1.5-1.5v-1a1.5 1.5 0 011.5-1.5z" fill="#335EEA" /><path d="M5.5 10h4a1.5 1.5 0 011.5 1.5v7A1.5 1.5 0 019.5 20h-4A1.5 1.5 0 014 18.5v-7A1.5 1.5 0 015.5 10zm9-6h4A1.5 1.5 0 0120 5.5v7a1.5 1.5 0 01-1.5 1.5h-4a1.5 1.5 0 01-1.5-1.5v-7A1.5 1.5 0 0114.5 4z" fill="#335EEA" opacity=".3" /> </g> </svg></div><div class="ms-4"><h6 class="text-uppercase text-success mb-0"> Modern UI Toolkit</h6><p class="fs-sm text-gray-700 mb-0"> Build beautiful user interfaces</p></div></a> <a class="list-group-item" href="/technology/trusted-package-registry.html"><div class="icon icon-sm text-danger"> <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z" /><path d="M5.5 2h13A1.5 1.5 0 0120 3.5v3A1.5 1.5 0 0118.5 8h-13A1.5 1.5 0 014 6.5v-3A1.5 1.5 0 015.5 2zM11 4a1 1 0 000 2h2a1 1 0 000-2h-2z" fill="#335EEA" opacity=".3" /><path d="M5.5 9h13a1.5 1.5 0 011.5 1.5v3a1.5 1.5 0 01-1.5 1.5h-13A1.5 1.5 0 014 13.5v-3A1.5 1.5 0 015.5 9zm5.5 2a1 1 0 000 2h2a1 1 0 000-2h-2zm-5.5 5h13a1.5 1.5 0 011.5 1.5v3a1.5 1.5 0 01-1.5 1.5h-13A1.5 1.5 0 014 20.5v-3A1.5 1.5 0 015.5 16zm5.5 2a1 1 0 000 2h2a1 1 0 000-2h-2z" fill="#335EEA" /> </g> </svg></div><div class="ms-4"><h6 class="text-uppercase text-danger mb-0"> Trusted Package Registry</h6><p class="fs-sm text-gray-700 mb-0"> Package management solution</p></div></a> <a class="list-group-item" href="https://platformio.org/"><div class="icon icon-sm text-dark"> <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <g fill="none" fill-rule="evenodd"><path d="M0 0h24v24H0z" /><path d="M18 14a3 3 0 110-6 3 3 0 010 6zm-9-3a4 4 0 110-8 4 4 0 010 8z" fill="#335EEA" opacity=".3" /><path d="M17.601 15c3.407.038 6.188 1.76 6.397 5.4.009.147 0 .6-.542.6H19.6c0-2.25-.744-4.328-1.999-6zm-17.6 5.2C.388 15.426 4.26 13 8.983 13c4.788 0 8.722 2.293 9.015 7.2.012.195 0 .8-.751.8H.727c-.25 0-.747-.54-.726-.8z" fill="#335EEA" /> </g> </svg></div><div class="ms-4"><h6 class="text-uppercase text-dark mb-0"> PlatformIO Open Source</h6><p class="fs-sm text-gray-700 mb-0"> Collaborative platform <i class="fe fe-log-out ms-3"></i></p></div></a></div></div></div></div></li><li class="nav-item"> <a class="nav-link" href="/blog/">Blog</a></li><li class="nav-item"> <a class="nav-link" href="/company/about.html">Company</a></li><li class="nav-item ps-lg-10 pt-2"><ul class="list-unstyled list-inline list-social "><li class="list-inline-item list-social-item me-3"> <a href="https://www.linkedin.com/company/platformio/" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/linkedin.svg" class="list-social-icon" alt="Follow on LinkedIn" title="Follow on LinkedIn"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://twitter.com/PlatformIO_Org" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/twitter.svg" class="list-social-icon" alt="Follow on Twitter" title="Follow on Twitter"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://github.com/platformio" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/github.svg" class="list-social-icon" alt="Follow on Github" title="Follow on Github"> </a></li></ul></li></ul></div></div></nav><div class="bg-light border-top"><nav class="bg-gray-200"><div class="container"><div class="row"><div class="col-12"><ol class="breadcrumb breadcrumb-scroll"><li class="breadcrumb-item"> <a href="/blog/" class="text-gray-700"> Blog </a></li><li class="breadcrumb-item"> <a href="/blog/engineering/" class="text-gray-700"> Engineering </a></li><li class="breadcrumb-item active" aria-current="page"> A Deep Dive into the ARM Debug Access Port</li></ol></div></div></div></nav><article class="bg-white"><section class="pt-8 pt-md-11"><div class="container"><div class="row justify-content-center"><div class="col-12 col-md-10 col-lg-9 col-xl-8"><h1 class="display-4 text-center"> A Deep Dive into the ARM Debug Access Port</h1><p class="text-center"> <span class="badge rounded-pill bg-primary-soft"><span class="h6 text-uppercase">Guest post</span></span></p><p class="lead mb-7 text-center text-muted"> Exploring the Architecture and Capabilities of the ARM Debug Access Port for Embedded System Debugging</p><div class="row align-items-center py-5 border-top border-bottom"><div class="col-auto"><div class="avatar avatar-lg"> <a href="https://www.linkedin.com/in/aleksander-kovalchuk-77030489/" target="_blank"><img src="/assets/img/avatars/akavalchuk.jpg" alt="Alex Kavalchuk" class="avatar-img rounded-circle"></a></div></div><div class="col ms-n5"><h6 class="text-uppercase mb-0"> <a href="https://www.linkedin.com/in/aleksander-kovalchuk-77030489/" target="_blank">Alex Kavalchuk</a></h6><div class="fs-sm text-muted"> Firmware & Embedded Engineer</div></div><div class="col-auto"> <span class="h6 text-uppercase text-muted d-none d-md-inline me-4"> Share: </span><ul class="list-unstyled list-inline list-social "><li class="list-inline-item list-social-item me-3"> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/linkedin.svg" class="list-social-icon" alt="Follow on LinkedIn" title="Follow on LinkedIn"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/twitter.svg" class="list-social-icon" alt="Follow on Twitter" title="Follow on Twitter"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/facebook.svg" class="list-social-icon" alt="Follow on Facebook" title="Follow on Facebook"> </a></li></ul></div></div></div></div></div></section><section class="pt-6 pt-md-8"><div class="container"><div class="row justify-content-center"><div class="col-12 col-md-10 col-lg-9 col-xl-8"><p><img class="figure-img img-fluid rounded" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/title.jpg" alt="PlatformIO lowers the barriers to entry the IoT market as much as possible" /></p><p>The ARM Debug Access Port (DAP) is a crucial component of the ARM debugging architecture that allows developers to gain access to and debug embedded systems running on ARM-based processors. The DAP provides a standardized interface for accessing and controlling various debug-related features, including debugging and programming interfaces, trace data, and system registers. Whether you are a seasoned embedded systems developer or just getting started with ARM-based SoC development, this article will provide valuable insights into the architecture of the ARM Debug Access Port and its functionality.</p><h3>Table of Contents</h3><ul id="markdown-toc"><li><a href="#debug-access-port-architecture" id="markdown-toc-debug-access-port-architecture">Debug Access Port Architecture</a></li><li><a href="#debug-port-dp" id="markdown-toc-debug-port-dp">Debug Port (DP)</a><ul><li><a href="#jtag-debug-port-jtag-dp" id="markdown-toc-jtag-debug-port-jtag-dp">JTAG Debug Port (JTAG-DP)</a></li><li><a href="#debug-port-registers" id="markdown-toc-debug-port-registers">Debug Port Registers</a></li><li><a href="#accessing-the-dp-registers" id="markdown-toc-accessing-the-dp-registers">Accessing the DP registers</a></li></ul></li><li><a href="#access-ports" id="markdown-toc-access-ports">Access Ports</a><ul><li><a href="#memory-access-port-registers" id="markdown-toc-memory-access-port-registers">Memory Access Port Registers</a></li><li><a href="#addressing-of-ap-registers" id="markdown-toc-addressing-of-ap-registers">Addressing of AP Registers</a></li><li><a href="#accessing-the-ap-registers" id="markdown-toc-accessing-the-ap-registers">Accessing the AP registers</a></li></ul></li><li><a href="#practical-part" id="markdown-toc-practical-part">Practical Part</a><ul><li><a href="#writing-a-variable-to-memory" id="markdown-toc-writing-a-variable-to-memory">Writing a variable to memory</a></li><li><a href="#reading-a-variable-from-memory" id="markdown-toc-reading-a-variable-from-memory">Reading a variable from memory</a></li></ul></li><li><a href="#links" id="markdown-toc-links">Links</a></li></ul><h2 id="debug-access-port-architecture">Debug Access Port Architecture</h2><p>The DAP is the primary “unit” of the ARM Debug Interface (ADI). DAP is a module that contains a set of registers and logic required to provide microcontroller debugging via a debug interface. DAP consists of two main components: <strong>Debug Port (DP)</strong> and <strong>Access Port (AP)</strong>.</p><div class="alert alert-warning" role="alert"> <b>Important</b>: Currently, most processors are implementing <b>ADIv5</b> (specified in Arm IHI0031E), while the newer <b>ADIv6</b> (see Arm IHI0074C) is being slowly phased in. Because it is more popular, I'll be focusing here on the ADIv5 standard.</div><p>The <strong>Debug Port</strong> provides control of the DAP and establishes a connection between the debugger and the target device. DP performs functions such as initialization, reset, and operation status checking. This module is conditionally divided into two parts: common and specific to a particular debugging protocol. The common part contains registers used to configure and operate the DP module, and the specific part is responsible for working with external debugging protocols. According to the documentation, our microcontroller supports two debugging protocols: SWD and JTAG, but in this series of articles, I decided to choose JTAG for consideration. Therefore, in the future, unless specifically stated otherwise, I will describe the operation of DAP specifically in the context of the JTAG protocol.</p><p>The <strong>Access Port</strong> provides access to various resources of the microcontroller, such as memory. The Access Port can have several data exchange interfaces, such as APB (Advanced Peripheral Bus), AHB (Advanced High-performance Bus), and AXI (Advanced eXtensible Interface), which are used to access various device resources. That is, access to all modules connected to the AHB bus, for example, will be provided through a special AHB-AP.</p><p>The approximate structural diagram of DAP is shown in the following figure:</p><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_Diagram.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_Diagram.png" /> </a><figcaption class="figure-caption text-center"> <br />Figure 1 - Debug Access Port (DAP)</figcaption></figure><p>Now let’s consider each component of DAP shown on this block diagram.</p><div class="alert alert-warning" role="alert"> <b>Note:</b> Despite the fact that this article was written on the basis of official documentation from Arm, nevertheless, not all topics are covered in it, so for detailed information you need to refer to the documentation.</div><h2 id="debug-port-dp">Debug Port (DP)</h2><h3 id="jtag-debug-port-jtag-dp">JTAG Debug Port (JTAG-DP)</h3><p>Since JTAG-DP must support the operation of the microcontroller via the JTAG protocol, external connection is made through the JTAG standard pins:</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">JTAG-DP pin</th><th scope="col">JTAG pin</th><th scope="col">Direction</th><th scope="col">Description</th></tr></thead><tbody><tr><td>DBGTDI</td><td>TDI</td><td>INPUT</td><td>Debug Data In</td></tr><tr><td>DBGTDO</td><td>TDO</td><td>OUTPUT</td><td>Debug Data Out</td></tr><tr><td>TCK</td><td>TCK</td><td>INPUT</td><td>Debug Clock</td></tr><tr><td>DBGTMS</td><td>TMS</td><td>INPUT</td><td>Debug Mode Select</td></tr><tr><td>DBGTRSTn</td><td>TRST</td><td>INPUT</td><td>Debug TAP Reset</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 1 - JTAG pinout</figcaption></figure><p>The JTAG-DP wire-level interface is through scan chains and comprises:</p><ul><li><p>a Debug TAP State Machine (DBGTAPSM) - This state machine is the cornerstone of the JTAG protocol and will be discussed in detail in the next article dedicated to this protocol.</p></li><li><p>an Instruction Register (IR) and associated IR scan chain, used to control the behavior of the JTAG-DP and the currently-selected data register. The specific data register we want to work with is selected by writing various commands to this register.</p></li><li><p>several Data Registers (DRs) and associated DR scan chains.</p></li></ul><h4 class="no_toc" id="jtag-registers">JTAG Registers</h4><h5 id="instruction-register-ir">Instruction Register (IR)</h5><p>The Debug TAP State Machine is implemented with a 4-bit instruction register (<code class="language-plaintext highlighter-rouge">IR</code>).</p><p>The Instruction Register contains the current command for the DAP controller. This register serves as a kind of entry point when working with DAP over the JTAG protocol. You need to write a command to this register that will determine the data register you want to work with.</p><p>The list of commands for the <code class="language-plaintext highlighter-rouge">IR</code> register is presented in the following table:</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">IR instruction value</th><th scope="col">DR name</th><th scope="col">DR length</th><th scope="col">Description</th></tr></thead><tbody><tr><td>b1000</td><td>ABORT</td><td>35</td><td>JTAG-DP Abort Register</td></tr><tr><td>b1010</td><td>DPACC</td><td>35</td><td>JTAG-DP DP Register</td></tr><tr><td>b1011</td><td>APACC</td><td>35</td><td>JTAG-DP AP Register</td></tr><tr><td>b1110</td><td>IDCODE</td><td>32</td><td>Device ID Code Register</td></tr><tr><td>b1111</td><td>BYPASS</td><td>1</td><td>JTAG-DP Bypass Register</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 2 - List of standard JTAG commands supported by DAP</figcaption></figure><h5 id="abort-instruction">ABORT Instruction</h5><p>The <code class="language-plaintext highlighter-rouge">ABORT</code> command in JTAG-DP is used to interrupt the execution of the current debugging operation and return control to the debugger. It allows performing a so-called <em>debug reset</em> of the processor.</p><p>During the debugging of a processor, the debugger establishes a connection with JTAG-DP and sends commands to read and write registers, execute instructions, etc. In some situations, there may be a need to interrupt the execution of the current debugging operation and return control to the debugger.</p><p>For example, in case of program hang or when there is an error in the debugging script. In such situations, the debugger can use the <code class="language-plaintext highlighter-rouge">ABORT</code> register to perform a <em>debug reset</em> of the processor and return control to the debugger.</p><h5 id="bypass-instruction">BYPASS Instruction</h5><p>The <code class="language-plaintext highlighter-rouge">BYPASS</code> command connects the TDI and TDO pins directly through a one-bit register called <code class="language-plaintext highlighter-rouge">BYPASS</code>. This command can be used to bypass some components connected to the JTAG chain. It may not be very clear now, but this command is closely related to the operation principle of the JTAG protocol and it’s difficult to explain it without discussing this principle. The next article will be dedicated to the JTAG protocol, so let’s postpone the explanation of this command for now. It’s not necessary for understanding the information in the current article.</p><h5 id="idcode-instruction">IDCODE Instruction</h5><p>The <code class="language-plaintext highlighter-rouge">IDCODE</code> command is used to identify the microchip connected to the JTAG chain. This command connects the <code class="language-plaintext highlighter-rouge">IDCODE</code> register, which contains a unique 32-bit identifier for the microchip, as the data register.</p><p>Reading the <code class="language-plaintext highlighter-rouge">IDCODE</code> register can be useful for verifying that the microchip corresponds to the expected model or version, as well as for checking the integrity and proper functioning of the JTAG chain.</p><h5 id="dpacc-instruction">DPACC Instruction</h5><p>The <code class="language-plaintext highlighter-rouge">DPACC</code> command connects the 35-bit <code class="language-plaintext highlighter-rouge">DPACC</code> (Debug Port Access) register as the data register, which is used to access some Debug Port registers.</p><h5 id="apacc-instruction">APACC Instruction</h5><p>The <code class="language-plaintext highlighter-rouge">APACC</code> command connects the 35-bit <code class="language-plaintext highlighter-rouge">APACC</code> (Access Port Access) register as the data register, which is used to access registers of the selected Access Port.</p><h4 class="no_toc" id="data-register-dr">Data Register (DR)</h4><p>The Data Register is a JTAG register through which all communication with one of the five registers listed in Table 1 occurs. In other words, by specifying the code of one of the five registers in the <code class="language-plaintext highlighter-rouge">IR</code> register, you are connecting the <code class="language-plaintext highlighter-rouge">DR</code> register to the selected register and any read or write operation to the <code class="language-plaintext highlighter-rouge">DR</code> register will be mapped to the selected register.</p><h3 id="debug-port-registers">Debug Port Registers</h3><p>The DP is responsible for configuring the debug module, controlling power and reset, and monitoring various errors that may occur during DAP operation. Special registers, such as <code class="language-plaintext highlighter-rouge">ABORT</code>, <code class="language-plaintext highlighter-rouge">IDCODE</code>, <code class="language-plaintext highlighter-rouge">CTRL/STAT</code>, and <code class="language-plaintext highlighter-rouge">SELECT</code> are responsible for all of these tasks.</p><h4 class="no_toc" id="abort-register-abort">Abort Register (ABORT)</h4><p>The Abort Register is always present on all DP implementations. Its main purpose is to force a DAP abort.</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Bits</th><th scope="col">Access</th><th scope="col">Function</th><th scope="col">Description</th></tr></thead><tbody><tr><td>[1:31]</td><td>RO</td><td>-</td><td>Reserved</td></tr><tr><td>[0]</td><td>WO</td><td>DAPABORT</td><td>Write 1 to this bit to generate a DAP abort. This aborts the current AP transaction. Do this only if the debugger has received WAIT responses over an extended period.</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 3 - DP ABORT register bits</figcaption></figure><p>When working with this register within JTAG-DP, the only writable bit is the <code class="language-plaintext highlighter-rouge">DAPABORT</code> bit. Writing to the other bits of this register results in undefined behavior according to the documentation.</p><h4 class="no_toc" id="id-code-register-idcode">ID Code Register (IDCODE)</h4><p>The Identification Code Register is always present on all DP implementations. It provides identification information about the ARM Debug Interface.</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Bits</th><th scope="col">Access</th><th scope="col">Function</th><th scope="col">Description</th></tr></thead><tbody><tr><td>[31:28]</td><td>RO</td><td>Version</td><td>Version code</td></tr><tr><td>[27:12]</td><td>RO</td><td>PARTNO</td><td>Part Number for the JTAG-DP - 0xBA00</td></tr><tr><td>[11:1]</td><td>RO</td><td>DESIGNER</td><td>JEDEC Designer ID, an 11-bit JEDEC code that identifies the designer of the ADI implementation - 0x23B</td></tr><tr><td>[0]</td><td>RO</td><td>-</td><td>Always</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 4 - DP IDCODE register bits</figcaption></figure><h4 class="no_toc" id="controlstatus-register-ctrlstat">Control/Status Register (CTRL/STAT)</h4><p>The <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register is always present on all DP implementations. It provides control of the DP and status information about the DP.</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Bits</th><th scope="col">Access</th><th scope="col">Function</th><th scope="col">Description</th></tr></thead><tbody><tr><td>[31]</td><td>RO</td><td>CSYSPWRUPACK</td><td>System power-up acknowledge</td></tr><tr><td>[30]</td><td>R/W</td><td>CSYSPWRUPREQ</td><td>System power-up request</td></tr><tr><td>[29]</td><td>RO</td><td>CDBGPWRUPACK</td><td>Debug power-up acknowledge</td></tr><tr><td>[28]</td><td>R/W</td><td>CDBGPWRUPREQ</td><td>Debug power-up request</td></tr><tr><td>[27]</td><td>RO</td><td>CDBGRSTACK</td><td>Debug reset acknowledge</td></tr><tr><td>[26]</td><td>R/W</td><td>CDBGRSTREQ</td><td>Debug reset request</td></tr><tr><td>[25:24]</td><td>-</td><td>-</td><td>Reserved, RAZ/SBZP</td></tr><tr><td>[23:12]</td><td>R/W</td><td>TRNCNT</td><td>Transaction counter</td></tr><tr><td>[11:8]</td><td>R/W</td><td>MASKLANE</td><td>Indicates the bytes to be masked in pushed compare and pushed verify operations</td></tr><tr><td>[7]</td><td>RO</td><td>WDATAERR</td><td>Set if a Write Data Error occurs</td></tr><tr><td>[6]</td><td>RO</td><td>READOK</td><td>This bit is set to 1 if the response to the previous AP or RDBUFF read was OK</td></tr><tr><td>[5]</td><td>RO</td><td>STICKYERR</td><td>Set if an error is returned by an AP transaction</td></tr><tr><td>[4]</td><td>RO</td><td>STICKYCMP</td><td>This bit is set to 1 when a match occurs on a pushed compare or a pushed verify operation</td></tr><tr><td>[3:2]</td><td>R/W</td><td>TRNMODE</td><td>Transfer mode for AP operations: 00 = Normal operation, 01 = Pushed verify operation, 10 = Pushed compare operation, 11 = Reserved.</td></tr><tr><td>[1]</td><td>RO</td><td>STICKYORUN</td><td>Overrun error flag</td></tr><tr><td>[0]</td><td>R/W</td><td>ORUNDETECT</td><td>This bit is set to 1 to enable overrun detection</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 5 - DP CTRL/STAT register bits</figcaption></figure><p>Let’s take a closer look at the bits of this register.</p><h5 id="sticky-flags-and-dp-error-responses">Sticky flags and DP error responses</h5><p>A read or write error might occur within the DAP, or come from the resource being accessed. In either case, when the error is detected the Sticky Error flag, <code class="language-plaintext highlighter-rouge">STICKYERR</code>, in the <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> Register is set to 1. A read/write error also might be generated if the debugger makes an AP transaction request while the debug power domain is powered down.</p><p>If a debugger issue <code class="language-plaintext highlighter-rouge">APACC</code> too fast, overrun may happen, the DP can be programmed so that if an overrun error occurs, the DP set the <code class="language-plaintext highlighter-rouge">STICKYORUN</code> flag in the <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register. But if overrun detection is on, the debugger must check for overrun errors after each sequence of APACC transactions, the DP will also no longer send FAULT response and WAIT response.</p><p>In any case, if a debugger receives a FAULT response from the DP, it must read the <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register to check the sticky flags.</p><h5 id="the-transaction-counter">The transaction counter</h5><p>The DP includes an AP transaction counter, <code class="language-plaintext highlighter-rouge">TRNCNT</code>, which enables a debugger to make a single AP transaction request to generate a sequence of AP transactions, thus accelerating code download or memory fill operations. The <code class="language-plaintext highlighter-rouge">TRNCNT</code> maps onto the <code class="language-plaintext highlighter-rouge">CTRL/STAT[23:12]</code> bitfield, and writing a value N (N&gt;=0) to this field generates N+1 AP transaction(s). If <code class="language-plaintext highlighter-rouge">TRNCNT</code> is not zero, it is decremented after each successful transaction, but it is not decremented when there are any sticky flags set. When reaches zero, <code class="language-plaintext highlighter-rouge">TRNCNT</code> does not auto-reload.</p><h5 id="power-control">Power control</h5><p>This is to enable an external debugger to connect to a potentially turned-off system and power up as much as required to get a basic level of debug access with a minimal understanding of the system.</p><p>The DAP model supports multiple power domains; there can be three power domains:</p><ul><li>Always on domain</li><li>System power domain</li><li>Debug power domain</li></ul><p>The DP registers reside in the always-on domain, and there are two control bits in the <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register:</p><ul><li>Bit [28], <code class="language-plaintext highlighter-rouge">CDBGPWRUPREQ</code>, used to request the system’s power manager to fully power up and enable clocks in the debug power domain.</li><li>Bit [30], <code class="language-plaintext highlighter-rouge">CSYSPWRUPREQ</code>, used to request the system’s power manager to fully power up and enable clocks in the system power domain.</li></ul><div class="alert alert-warning" role="alert"> <b>Note:</b> Both bits need to be set during initialization, to ensure the MCU is fully powered up and clocks are enabled.</div><h5 id="debug-reset-control">Debug Reset Control</h5><p>The DP <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register provides bits [27:26], for reset control of the debug domain. The debug domain controlled by these signals covers the internal DAP and the connection between the DAP and the debug components, for example, the debug bus. The two bits provide a debug reset request, <code class="language-plaintext highlighter-rouge">CDBGRSTREQ</code>, and a reset acknowledge, <code class="language-plaintext highlighter-rouge">CDBGRSTACK</code>, and the associated signals provide a connection to a system reset controller. The DP registers are in the always-on power domain on the external interface side of the DP. Therefore, the registers can be driven at any time, to generate a reset request to the system reset controller.</p><h4 class="no_toc" id="ap-select-register-select">AP Select Register, SELECT</h4><p>The AP Select Register is always present on all DP implementations. Its main purpose is to select the current Access Port (AP) and the active four-word register bank within that AP.</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Bits</th><th scope="col">Function</th><th scope="col">Description</th></tr></thead><tbody><tr><td>[31:24]</td><td>APSEL</td><td>Selects the current AP (AHB-AP, APB-AP, JTAG-AP)</td></tr><tr><td>[23:8]</td><td>-</td><td>Reserved</td></tr><tr><td>[7:4]</td><td>APBANKSEL</td><td>Select the active four-word register bank on the current AP</td></tr><tr><td>[3:1]</td><td>-</td><td>Reserved</td></tr><tr><td>[0]</td><td>-</td><td>Always</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 6 - DP SELECT register bits</figcaption></figure><h5 id="ap-selection">AP selection</h5><p>As DAP can contain multiple APs, we need to have the ability to select a specific AP with which we want to work at the moment. And it is the <code class="language-plaintext highlighter-rouge">APSEL</code> bits that are responsible for this selection. They specify the number of the AP that will be used for access.</p><h5 id="bank-of-registers-selection">Bank of registers selection</h5><p>The <code class="language-plaintext highlighter-rouge">APBANKSEL</code> bits are used to select the register bank to which access will be made. Register banks are used to organize registers associated with specific functional blocks within the microcontroller. For example, a register bank may be allocated for the core processor debug registers, while another bank may be allocated for the peripheral device debug registers.</p><h3 id="accessing-the-dp-registers">Accessing the DP registers</h3><p>As mentioned earlier, to access the DP registers <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> and <code class="language-plaintext highlighter-rouge">SELECT</code>, the <code class="language-plaintext highlighter-rouge">DPACC</code> register is used, and working with this register has its own peculiarities. Let’s take a closer look at the algorithm for accessing the DP registers.</p><p>DP registers can be divided into two categories: control registers and access registers. Control registers contain information about the state of the debug logic, such as the status of command execution or the reset state. Access registers are used to read and write data from registers that control the operation of the debug logic.</p><p>In this context, we will focus on the DP access registers, which provide access to the debug logic. DP access registers can be addressed through the <code class="language-plaintext highlighter-rouge">DPACC</code> register and include control registers (<code class="language-plaintext highlighter-rouge">CTRL/STAT</code> and <code class="language-plaintext highlighter-rouge">SELECT</code>), access registers to the application logic (<code class="language-plaintext highlighter-rouge">APACC</code>), bypass register (<code class="language-plaintext highlighter-rouge">BYPASS</code>), and device identification register (<code class="language-plaintext highlighter-rouge">IDCODE</code>). Working with these registers has its own peculiarities and requires knowledge of the <code class="language-plaintext highlighter-rouge">DPACC</code> register format, which we will discuss further.</p><h4 class="no_toc" id="dpacc-register-format">DPACC register format</h4><p>The <code class="language-plaintext highlighter-rouge">DPACC</code> register has a size of 35 bits and its format depends on the operation (read or write) we want to perform.</p><h5 id="format-for-writing">Format for writing:</h5><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_write_format.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_write_format.png" /> </a><figcaption class="figure-caption text-center"> <br />Picture 2 - DPACC register write format</figcaption></figure><ul><li>D - these are data bits. That is, in these 32 bits, you store the value you want to write to the selected register.</li><li>A - these are address bits of the DP register. These two bits determine the specific DP register you want to work with:</li></ul><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Address</th><th scope="col">A[3:2]</th><th scope="col">Register</th></tr></thead><tbody><tr><td>0x04</td><td>[01]</td><td>CTRL/STAT</td></tr><tr><td>0x08</td><td>[10]</td><td>SELECT</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 7 - A[3:2] bits for DPACC</figcaption></figure><div class="alert alert-warning" role="alert"> <b>Note:</b> <b>DR</b> register in JTAG-DP is like a common register for five data registers (<b>ABORT</b>, <b>BYPASS</b>, <b>IDCODE</b>, <b>DPACC</b>, <b>APACC</b>), and by writing or reading data from/to it, you write/read data to/from one of the five data registers selected by the command in the <b>IR</b> register. Similarly, for working with the <b>CTRL/STAT</b> and <b>SELECT</b> registers, when you select the <b>DPACC</b> register for operation with the <b>DPACC</b> command in the <b>IR</b> register, the <b>DR</b> register is mapped to the <b>DPACC</b> register, and the <b>DPACC</b> register is mapped to one of the shared DP registers: <b>CTRL/STAT</b> or <b>SELECT</b>. This results in a chain of registers: <b>DR --&gt; DPACC --&gt; CTRL/STAT</b> or <b>SELECT</b>, for example. Therefore, by writing/reading data to/from the <b>DR</b> register, you write/read data to/from the <b>CTRL/STAT</b> or <b>SELECT</b> register.</div><ul><li>RnW - this bit for the write operation has the value 0.</li></ul><h5 id="format-for-reading">Format for reading:</h5><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_read_format.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_read_format.png" /> </a><figcaption class="figure-caption text-center"> <br />Picture 3 - DPACC register read format</figcaption></figure><ul><li>D - these are data bits. I.e. in these 32 bits you get the value read from the register.</li><li>ACK[2:0] - Acknowledge of read operation:</li></ul><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">ACK</th><th scope="col">Value</th></tr></thead><tbody><tr><td>0b010</td><td>OK/FAULT</td></tr><tr><td>0b001</td><td>WAIT</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 8 - Acknowledge codes</figcaption></figure><h4 class="no_toc" id="operation-algorithm">Operation algorithm</h4><p>Now let’s step by step go through the algorithms for writing/reading a new value to/from the DP register:</p><h5 id="algorithm-for-writing">Algorithm for writing</h5><ul><li>Write the value <code class="language-plaintext highlighter-rouge">0b1010</code> (the code for the <code class="language-plaintext highlighter-rouge">DPACC</code> register) to the <code class="language-plaintext highlighter-rouge">IR</code> register.</li><li>Write 35 bits to the <code class="language-plaintext highlighter-rouge">DR</code> register according to the format described above:<ul><li>DATA[31:0] - the data we want to write</li><li>A[3:2] - the selected register</li><li>RnW - <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li></ul><h5 id="algorithm-for-reading">Algorithm for reading</h5><ul><li>Write the value <code class="language-plaintext highlighter-rouge">0b1010</code> (the code for the <code class="language-plaintext highlighter-rouge">DPACC</code> register) to the <code class="language-plaintext highlighter-rouge">IR</code> register.</li><li>Write a <strong>request</strong> to read the register to the <code class="language-plaintext highlighter-rouge">DR</code> register:<ul><li>DATA[31:0] - <code class="language-plaintext highlighter-rouge">0x00</code></li><li>A[3:2] - the selected register</li><li>RnW - <code class="language-plaintext highlighter-rouge">0b1</code></li></ul></li><li>Read 35 bits from the <code class="language-plaintext highlighter-rouge">DR</code> register:<ul><li>DATA[31:0] - the data read from the register</li><li>ACK[2:0] - Acknowledge code.</li></ul></li></ul><div class="alert alert-warning" role="alert"> <b>Note:</b> As you may have noticed, during the read operation, we access the <b>DR</b> register twice. The first time, we form a <b>request</b> to read data from a specific register, i.e., we inform the microcontroller that we would like to read data from a particular register. The actual reading of the data happens during the second access to the <b>DR</b> register.</div><h2 id="access-ports">Access Ports</h2><p>Access ports provide access to system resources such as debug registers, trace port registers, a ROM table, or system memory.</p><p>An ARM Debug Interface always includes at least one Access Port and might contain multiple APs. The simplest ARM Debug Interface uses a single AP to connect to a single debug component.</p><p>Multiple APs can be added to the DAP, depending on the needs. ARM provides specifications for two APs :</p><ul><li><strong>Memory Access Port (MEM-AP)</strong>. This AP provides access to the core memory and registers.</li><li><strong>JTAG Access Port (JTAG-AP)</strong>. This AP allows to connect a JTAG chain to the DAP.</li></ul><p>For this series of articles, the Memory Access Port is of the greatest interest, so we will focus on it. For information about the JTAG Access Port, please refer to the documentation.</p><h3 id="memory-access-port-registers">Memory Access Port Registers</h3><p>The specification for ARM DAP describes the following Memory Access Port registers:</p><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">MEM-AP register</th><th scope="col">Address</th><th scope="col">Register bank (APBANKSEL)</th><th scope="col">Offset (A[3:2])</th></tr></thead><tbody><tr><td>CSW</td><td>0x00</td><td>0x00</td><td>0b00</td></tr><tr><td>TAR</td><td>0x04</td><td>0x00</td><td>0b01</td></tr><tr><td>DRW</td><td>0x0C</td><td>0x00</td><td>0b11</td></tr><tr><td>BD0</td><td>0x10</td><td>0x01</td><td>0b00</td></tr><tr><td>BD1</td><td>0x14</td><td>0x01</td><td>0b01</td></tr><tr><td>BD2</td><td>0x18</td><td>0x01</td><td>0b10</td></tr><tr><td>BD3</td><td>0x1C</td><td>0x01</td><td>0b11</td></tr><tr><td>CFG</td><td>0xF4</td><td>0x0F</td><td>0b01</td></tr><tr><td>BASE</td><td>0xF8</td><td>0x0F</td><td>0b10</td></tr><tr><td>IDR</td><td>0xFC</td><td>0x0F</td><td>0b11</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 9 - Memory Access Port registers</figcaption></figure><h4 class="no_toc" id="controlstatus-word-register-csw">Control/Status Word Register, CSW</h4><p>The <code class="language-plaintext highlighter-rouge">CSW</code> register is used to configure the access mode to the memory and peripheral devices of the ARM microcontroller.</p><p>Using the <code class="language-plaintext highlighter-rouge">CSW</code> register, you can configure parameters such as the size of the transmitted data (8, 16, or 32 bits), enable the auto-increment mode of the memory address to which access is made, and so on.</p><h4 class="no_toc" id="the-transfer-address-register-tar">The Transfer Address Register (TAR)</h4><p>This register is used to specify the address to be accessed through the AP. This address can be the address of a register, memory, or any other available address on the device.</p><p>When a new value is set in <code class="language-plaintext highlighter-rouge">TAR</code> in the AP, all subsequent read/write operations will be performed at the specified address until <code class="language-plaintext highlighter-rouge">TAR</code> is changed to another address and the auto-increment mode is turned off.</p><p>In general, before accessing any address through the AP, it is necessary to load this address into the <code class="language-plaintext highlighter-rouge">TAR</code>.</p><h4 class="no_toc" id="the-data-readwrite-register-drw">The Data Read/Write Register (DRW)</h4><p>The <code class="language-plaintext highlighter-rouge">DRW</code> (Data Register for Write) in the Access Port is used for writing data to or reading data from the target resource.</p><p>To write data to <code class="language-plaintext highlighter-rouge">DRW</code>, the address needs to be set in the <code class="language-plaintext highlighter-rouge">TAR</code> (Transfer Address Register), and the necessary access parameters need to be configured in <code class="language-plaintext highlighter-rouge">CSW</code>. After that, data can be written to <code class="language-plaintext highlighter-rouge">DRW</code> and transferred to the target resource. Similarly, to read data from the target resource, the access parameters in <code class="language-plaintext highlighter-rouge">CSW</code> need to be configured and the read address needs to be set in <code class="language-plaintext highlighter-rouge">TAR</code>. Then, the data from the target device will be transferred to <code class="language-plaintext highlighter-rouge">DRW</code>, ready to be read.</p><h4 class="no_toc" id="banked-data-registers-0-to-3-bd0-to-bd3">Banked Data Registers 0 to 3 (BD0 to BD3)</h4><p>The <code class="language-plaintext highlighter-rouge">BD0</code>, <code class="language-plaintext highlighter-rouge">BD1</code>, <code class="language-plaintext highlighter-rouge">BD2</code> and <code class="language-plaintext highlighter-rouge">BD3</code> registers in the Access Port are used for transferring/receiving data between the target device and the debugging system.</p><p>Using these registers can be useful when a large amount of data needs to be transferred or when a higher data transfer speed is required than what is possible with the <code class="language-plaintext highlighter-rouge">TAR</code> and <code class="language-plaintext highlighter-rouge">DRW</code> registers. Together, these four Banked Data Registers provide access to four words of memory space, starting at the address specified in the <code class="language-plaintext highlighter-rouge">TAR</code>. However, transferring data through the <code class="language-plaintext highlighter-rouge">BD0</code>, <code class="language-plaintext highlighter-rouge">BD1</code>, <code class="language-plaintext highlighter-rouge">BD2</code> and <code class="language-plaintext highlighter-rouge">BD3</code> registers requires more complex logic than transferring through the <code class="language-plaintext highlighter-rouge">TAR</code> and <code class="language-plaintext highlighter-rouge">DRW</code> registers and may require additional software to manage these registers.</p><h4 class="no_toc" id="configuration-register-cfg">Configuration Register (CFG)</h4><p>The CFG Register holds information about the configuration of the MEM-AP. In particular, it indicates whether accesses to the connected memory system are big-endian or little-endian.</p><h4 class="no_toc" id="debug-base-address-register-base">Debug Base Address Register (BASE)</h4><p>The BASE Register is a pointer to the connected memory system. It points to one of: - the start of a set of debug registers for the single connected debug component - the start of a ROM Table that describes the connected debug components</p><h4 class="no_toc" id="identification-register-idr">Identification Register (IDR)</h4><p>The IDR identifies the Memory Access Port. The IDR is the only register that must be implemented by any Access Port.</p><h3 id="addressing-of-ap-registers">Addressing of AP Registers</h3><p>One of the four registers within the DP is the AP Select Register (<code class="language-plaintext highlighter-rouge">SELECT</code>). This register specifies a particular Access Port and a bank of four 32-bit words within the register map of that AP.</p><p>In any AP access transaction from the debugger, the two address bits A[3:2] are decoded to select one of the four 32-bit words from the register bank indicated by the <code class="language-plaintext highlighter-rouge">SELECT</code> register (see Table 9). In other words, they select a specific register within the selected four-register bank.</p><p>This access model is shown in Figure 4 shows how the contents of the <code class="language-plaintext highlighter-rouge">SELECT</code> register are combined with the A[3:2] bits of the <code class="language-plaintext highlighter-rouge">APACC</code> scan-chain to form the address of a register in an AP.</p><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_ap_addr_creation.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_ap_addr_creation.png" /> </a><figcaption class="figure-caption text-center"> <br />Figure 4 - MEM-AP access model</figcaption></figure><p>As can be seen in this figure, Memory Access Port registers are all 32-bit long (4 bytes), two fields in the DP <code class="language-plaintext highlighter-rouge">SELECT</code> register select the AP (<code class="language-plaintext highlighter-rouge">APSEL</code> field) and the register bank in the AP (<code class="language-plaintext highlighter-rouge">APBANKSEL</code> field), and finally, the <code class="language-plaintext highlighter-rouge">A[3:2]</code> field of <code class="language-plaintext highlighter-rouge">APACC</code> specify the exact AP register in the bank.</p><h3 id="accessing-the-ap-registers">Accessing the AP registers</h3><p>The situation with accessing the AP registers is the same as accessing the DP registers, except that instead of the <code class="language-plaintext highlighter-rouge">DPACC</code> register, the <code class="language-plaintext highlighter-rouge">APACC</code> register is used. When you write <code class="language-plaintext highlighter-rouge">APACC</code> command in the <code class="language-plaintext highlighter-rouge">IR</code> register, the <code class="language-plaintext highlighter-rouge">DR</code> register is mapped to the <code class="language-plaintext highlighter-rouge">APACC</code> register and the <code class="language-plaintext highlighter-rouge">APACC</code> register is mapped to one of the common AP registers defined in Table 9. This creates a chain of registers: <code class="language-plaintext highlighter-rouge">DR --&gt; APACC --&gt; AP Reg</code>.</p><h4 class="no_toc" id="apacc-register-format">APACC register format</h4><p>These registers also have a size of 35 bits, and the value of the bits depends on whether we write something to these registers or read from them.</p><h5 id="format-for-writing-1">Format for writing:</h5><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_write_format.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_write_format.png" /> </a><figcaption class="figure-caption text-center"> <br />Figure 5 - APACC register write format</figcaption></figure><ul><li>D - This is the data bits. In these 32 bits, you store the value that you want to write to the selected register.</li><li>A - These are the sub-address bits of the AP register. These two bits, together with four more bits from the DP register <code class="language-plaintext highlighter-rouge">SELECT</code>, determine the specific AP register you want to work with:</li></ul><figure class="figure mb-7"><table class="table table-sm table-striped table-bordered" style="text-align: center"><thead class="thead"><tr class="table-dark"><th scope="col">Address</th><th scope="col">A[3:2]</th><th scope="col">Register</th></tr></thead><tbody><tr><td>0x00</td><td>[00]</td><td>CSW</td></tr><tr><td>0x04</td><td>[01]</td><td>TAR</td></tr><tr><td>0x0C</td><td>[11]</td><td>DRW</td></tr><tr><td>0x10</td><td>[00]</td><td>BD0</td></tr><tr><td>0x14</td><td>[01]</td><td>BD1</td></tr><tr><td>0x18</td><td>[10]</td><td>BD2</td></tr><tr><td>0x1C</td><td>[11]</td><td>BD3</td></tr><tr><td>0xF4</td><td>[01]</td><td>CFG</td></tr><tr><td>0xF8</td><td>[10]</td><td>BASE</td></tr><tr><td>0xFC</td><td>[11]</td><td>IDR</td></tr></tbody></table><figcaption class="figure-caption text-center"> Table 10 - A[3:2] for MEM-AP registers</figcaption></figure><ul><li>RnW - This bit has a value of 0 for a write operation.</li></ul><h5 id="format-for-reading-1">Format for reading:</h5><figure class="figure mb-7"> <a data-bigpicture="{&quot;imgSrc&quot;: &quot;/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_read_format.png&quot;}" href="#"> <img class="img-fluid screenshot mw-md-100" src="/assets/posts/2023-05-09-diving-into-arm-debug-access-port/DAP_dpacc_read_format.png" /> </a><figcaption class="figure-caption text-center"> <br />Figure 6 - APACC register read format</figcaption></figure><ul><li>DATA[31:0] - These are data bits. In other words, these 32 bits contain the value that you read from the selected register.</li><li><p>Bits 2:0 (ACK[2:0]) = 3-bit Acknowledge of read operation:</p><ul><li>0b010 = OK/FAULT</li><li>0b001 = WAIT</li></ul></li></ul><h4 class="no_toc" id="operation-algorithm-1">Operation algorithm</h4><p>Now let’s go step-by-step through the algorithms for writing/reading a new value to/from an AP register:</p><h5 id="algorithm-for-writing-1">Algorithm for writing</h5><ul><li>Write the <code class="language-plaintext highlighter-rouge">DPACC</code> command (<code class="language-plaintext highlighter-rouge">0b1010</code>) to the <code class="language-plaintext highlighter-rouge">IR</code> register</li><li>Write 35 bits to the <code class="language-plaintext highlighter-rouge">DR</code> register in which we indicate that we are working with the <code class="language-plaintext highlighter-rouge">SELECT</code> register and write the corresponding values of the APSEL[31:24] and APBANKSEL[7:4] bits to this register:<ul><li>DATA [31:0]:<ul><li>APSEL[31:24] - select the desired AP</li><li>APBANKSEL[7:4] - select the desired bank of registers</li></ul></li><li>A[3:2] - <code class="language-plaintext highlighter-rouge">0b10</code> - address of <code class="language-plaintext highlighter-rouge">SELECT</code> register (see Table 7)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>Write the <code class="language-plaintext highlighter-rouge">APACC</code> command (<code class="language-plaintext highlighter-rouge">0b1011</code>) to the <code class="language-plaintext highlighter-rouge">IR</code> register</li><li>Write the data to the <code class="language-plaintext highlighter-rouge">DR</code> register according to the described bit values (see Figure 5):<ul><li>DATA[31:0] = data which need to be written</li><li>A[3:2] = Address of Memory Access Port register (see Table 9).</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li></ul><h5 id="algorithm-for-reading-1">Algorithm for reading</h5><ul><li>Write the <code class="language-plaintext highlighter-rouge">DPACC</code> command (<code class="language-plaintext highlighter-rouge">0b1010</code>) to the <code class="language-plaintext highlighter-rouge">IR</code> register</li><li>Write 35 bits to the <code class="language-plaintext highlighter-rouge">DR</code> register in which we indicate that we are working with the <code class="language-plaintext highlighter-rouge">SELECT</code> register and write the corresponding values of the APSEL[31:24] and APBANKSEL[7:4] bits to this register:<ul><li>DATA[31:0]:<ul><li>APSEL[31:24] - select the desired AP</li><li>APBANKSEL[7:4] - select the desired bank of registers</li></ul></li><li>A[3:2] - <code class="language-plaintext highlighter-rouge">0b10</code> - address of <code class="language-plaintext highlighter-rouge">SELECT</code> register (see Table 7).</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b1</code></li></ul></li><li>Write the <code class="language-plaintext highlighter-rouge">APACC</code> command (<code class="language-plaintext highlighter-rouge">0b1011</code>) to the <code class="language-plaintext highlighter-rouge">IR</code> register</li><li>Create the data read request. Write in <code class="language-plaintext highlighter-rouge">DR</code> next data:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00000000</code></li><li>A[3:2] = Address of Memory Access Port register (see Table 9).</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b1</code></li></ul></li><li>Read 35 bits from the <code class="language-plaintext highlighter-rouge">DR</code> register</li><li>Check the values of the ACK[2:0] bits and if they are not equal to <code class="language-plaintext highlighter-rouge">OK/FAULT (0b001)</code>, then the data was read, if it is equal to <code class="language-plaintext highlighter-rouge">WAIT (0b001)</code>, we need to repeat the reading because the data is not ready.</li></ul><h2 id="practical-part">Practical Part</h2><p>Let’s take an example of an algorithm for writing values to the memory of a microcontroller and reading data from memory.</p><h3 id="writing-a-variable-to-memory">Writing a variable to memory</h3><p>Let’s try to write the value <code class="language-plaintext highlighter-rouge">0xAA55AA55</code> to the memory cell at address <code class="language-plaintext highlighter-rouge">0x20000000</code></p><ol><li>Write <code class="language-plaintext highlighter-rouge">0b1010</code> (the <code class="language-plaintext highlighter-rouge">DPACC</code> register code) into the <code class="language-plaintext highlighter-rouge">IR</code> register.</li><li>Some settings in the <code class="language-plaintext highlighter-rouge">AP</code> register <code class="language-plaintext highlighter-rouge">CSW</code> need to be configured. To access this register, we need to select the corresponding <code class="language-plaintext highlighter-rouge">AP</code> and register bank in the <code class="language-plaintext highlighter-rouge">DP SELECT</code> register. Write to the <code class="language-plaintext highlighter-rouge">DR</code> register:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00</code><ul><li>APSEL[31:24] = <code class="language-plaintext highlighter-rouge">0x00</code></li><li>APBANKSEL[7:4] = <code class="language-plaintext highlighter-rouge">0x00</code></li></ul></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b10</code> (address of <code class="language-plaintext highlighter-rouge">SELECT</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>Next, we need to write the <code class="language-plaintext highlighter-rouge">CSW</code> register. Since this is an <code class="language-plaintext highlighter-rouge">AP</code> register, we need to use the <code class="language-plaintext highlighter-rouge">APACC</code> register to access it:<ul><li>Write <code class="language-plaintext highlighter-rouge">0b1011</code> (the <code class="language-plaintext highlighter-rouge">APACC</code> register code) into the <code class="language-plaintext highlighter-rouge">IR</code> register.</li></ul></li><li>Form the data for the configuration: set the data size for writing to 32-bits (<code class="language-plaintext highlighter-rouge">Size[0:2] = 0b010</code>), disable the auto-increment function of the address (<code class="language-plaintext highlighter-rouge">AddrInc[5:4] = 0b00</code>). Write to <code class="language-plaintext highlighter-rouge">DR</code>:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00000002</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b00</code> (address of <code class="language-plaintext highlighter-rouge">CSW</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>Then we need to set the address of the memory cell to which we want to write the data. This is done through the <code class="language-plaintext highlighter-rouge">AP</code> register <code class="language-plaintext highlighter-rouge">TAR</code>. And since this register belongs to the same <code class="language-plaintext highlighter-rouge">AP</code> as <code class="language-plaintext highlighter-rouge">CSW</code> and is in the same bank, we can omit the reference to the <code class="language-plaintext highlighter-rouge">DP SELECT</code> register and immediately write the address value. Write to <code class="language-plaintext highlighter-rouge">DR</code>:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x20000000</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b01</code> (address of <code class="language-plaintext highlighter-rouge">TAR</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>The last step is to actually write the data. To do this, we need to write them to the <code class="language-plaintext highlighter-rouge">DRW</code> register. Write to <code class="language-plaintext highlighter-rouge">DRW</code>:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0xAA55AA55</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b11</code> (address of <code class="language-plaintext highlighter-rouge">DRW</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li></ol><h3 id="reading-a-variable-from-memory">Reading a variable from memory</h3><p>We know how to write data to memory, and now it’s time to read that data. The algorithm for reading largely repeats the steps for writing, but there are still some differences:</p><ol><li>Write <code class="language-plaintext highlighter-rouge">0b1010</code> (the <code class="language-plaintext highlighter-rouge">DPACC</code> register code) into the <code class="language-plaintext highlighter-rouge">IR</code> register.</li><li>We need to configure some settings in the <code class="language-plaintext highlighter-rouge">CSW</code> register of the <code class="language-plaintext highlighter-rouge">AP</code>. To access this register, we need to select the corresponding <code class="language-plaintext highlighter-rouge">AP</code> and register bank in the <code class="language-plaintext highlighter-rouge">DP SELECT</code> register. Using the data from the table, we form 35 bits of data that we write to the <code class="language-plaintext highlighter-rouge">DR</code> register:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00</code><ul><li>APSEL[31:24] = <code class="language-plaintext highlighter-rouge">0x00</code></li><li>APBANKSEL[7:4] = <code class="language-plaintext highlighter-rouge">0x00</code></li></ul></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b10</code> (address of <code class="language-plaintext highlighter-rouge">SELECT</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>Next, we need to write directly to the <code class="language-plaintext highlighter-rouge">CSW</code> register. Since this is an <code class="language-plaintext highlighter-rouge">AP</code> register, we need to use the <code class="language-plaintext highlighter-rouge">APACC</code> register to access it:<ul><li>Write <code class="language-plaintext highlighter-rouge">0b1011</code> (the <code class="language-plaintext highlighter-rouge">APACC</code> register code) into the <code class="language-plaintext highlighter-rouge">IR</code> register.</li></ul></li><li>We form the data for configuration: we set the data size for writing to 32 bits (<code class="language-plaintext highlighter-rouge">Size[0:2] = 0b010</code>) and disable the auto-increment address function (<code class="language-plaintext highlighter-rouge">AddrInc[5:4] = 0b00</code>). Write to <code class="language-plaintext highlighter-rouge">DR</code>:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00000002</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b00</code> (address of <code class="language-plaintext highlighter-rouge">CSW</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>Next, we need to set the address of the memory cell from which we will read the data. This is done through the <code class="language-plaintext highlighter-rouge">TAR</code> register of the <code class="language-plaintext highlighter-rouge">AP</code>. And since this register belongs to the same <code class="language-plaintext highlighter-rouge">AP</code> as <code class="language-plaintext highlighter-rouge">CSW</code> and is in the same bank, we can skip the <code class="language-plaintext highlighter-rouge">DP SELECT</code> register access and immediately write the address value:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x20000000</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b01</code> (address of <code class="language-plaintext highlighter-rouge">TAR</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b0</code></li></ul></li><li>We form a read request. To do this, we write to the <code class="language-plaintext highlighter-rouge">DRW</code> register:<ul><li>DATA[31:0] = <code class="language-plaintext highlighter-rouge">0x00</code></li><li>A[3:2] = <code class="language-plaintext highlighter-rouge">0b11</code> (address of <code class="language-plaintext highlighter-rouge">DRW</code> register)</li><li>RnW = <code class="language-plaintext highlighter-rouge">0b1</code></li></ul></li><li>Read the <code class="language-plaintext highlighter-rouge">DRW</code> register by reading 35 bits from the <code class="language-plaintext highlighter-rouge">DR</code> register.</li><li>Check the values of the <code class="language-plaintext highlighter-rouge">ACK[2:0]</code> bits, and if they are equal to <code class="language-plaintext highlighter-rouge">0b001</code>, the read operation is complete. However, to ensure that the read data is valid, we need to check for read errors.</li><li>To check error flags, we need to read the <code class="language-plaintext highlighter-rouge">CTRL/STAT</code> register of the <code class="language-plaintext highlighter-rouge">DP</code> and, first of all, check the <code class="language-plaintext highlighter-rouge">STICKYERR</code> flag.</li></ol><h2 id="links">Links</h2><ul><li><a href="https://developer.arm.com/documentation/ihi0031/latest/" target="_blank">ARM® Debug Interface v5. Architecture Specification</a></li><li><a href="https://interrupt.memfault.com/blog/a-deep-dive-into-arm-cortex-m-debug-interfaces" target="_blank">A Deep Dive into ARM Cortex-M Debug Interfaces</a></li><li><a href="https://www.allaboutcircuits.com/technical-articles/jtag-implementation-arm-core-devices/" target="_blank">JTAG Implementation in Arm Core Devices</a></li><li>AN115533 - Serial Wire Debug (SWD) programming specification</li></ul><h2 class="no_toc" id="stay-in-touch-with-us">Stay in touch with us</h2><p>Stay tuned to this blog or follow us on <a href="https://www.linkedin.com/company/platformio" target="_blank">LinkedIn</a> and Twitter <a href="https://twitter.com/PlatformIO_Org" target="_blank">@PlatformIO_Org</a> to keep up to date with the latest news, articles and tips!</p></div></div></div></section><section class="py-6 py-md-8"><div class="container"><div class="row justify-content-center"><div class="col-12 col-md-10 col-lg-9 col-xl-8"><div class="row align-items-center py-5 border-top border-bottom"><div class="col-auto"><div class="avatar avatar-lg"> <a href="https://www.linkedin.com/in/aleksander-kovalchuk-77030489/" target="_blank"><img src="/assets/img/avatars/akavalchuk.jpg" alt="Alex Kavalchuk" class="avatar-img rounded-circle"></a></div></div><div class="col ms-n5"><h6 class="text-uppercase mb-0"> <a href="https://www.linkedin.com/in/aleksander-kovalchuk-77030489/" target="_blank">Alex Kavalchuk</a></h6><div class="fs-sm text-muted"> <time datetime="2023-05-09T00:00:00+03:00"> Published on 9th May 2023 </time></div></div><div class="col-auto"> <span class="h6 text-uppercase text-muted d-none d-md-inline me-4"> Share: </span><ul class="list-unstyled list-inline list-social "><li class="list-inline-item list-social-item me-3"> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/linkedin.svg" class="list-social-icon" alt="Follow on LinkedIn" title="Follow on LinkedIn"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/twitter.svg" class="list-social-icon" alt="Follow on Twitter" title="Follow on Twitter"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fpiolabs.com%2Fblog%2Fengineering%2Fdiving-into-arm-debug-access-port.html" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/facebook.svg" class="list-social-icon" alt="Follow on Facebook" title="Follow on Facebook"> </a></li></ul></div></div></div></div></div></section></article><section class="pt-4 pt-md-6 pb-8 pb-md-10 bg-white"><div class="container"><div class="row justify-content-center"><div class="col-12 col-md-10 col-lg-9 col-xl-8"><div class="row align-items-center"><div class="col-12 col-md"><h3 class="mb-1"> Have questions?</h3><p class="fs-lg text-muted mb-6 mb-md-0"> Join the discussion on our forum</p></div><div class="col-12 col-md-auto"> <a href="https://community.platformio.org/t/a-deep-dive-into-the-arm-debug-access-port/33712" class="btn btn-primary-soft me-1 lift" target="_blank"> Continue discussion <i class="fe fe-arrow-right ms-3"></i> </a></div></div></div></div></div></section><section class="pt-7 pb-9 pt-md-10 bg-light border-top"><div class="container"><div class="row align-items-center mb-5"><div class="col-12 col-md"><h3 class="mb-0"> Popular posts</h3></div><div class="col-12 col-md-auto"> <a href="/blog/latest.html" class="btn btn-sm btn-outline-gray-300 d-none d-md-inline"> View more </a></div></div><div class="row"><div class="col-12 col-md-6 col-lg-4 d-flex"><div class="card mb-6 shadow-light-lg lift lift-lg"> <a class="card-img-top" href="/blog/news/platformio-oss-july-2022-updates.html"> <img src="/assets/posts/oss-updates/platformio-oss-july-news.jpg" alt="PlatformIO Open Source July Updates" class="card-img-top"><div class="position-relative"><div class="shape shape-bottom shape-fluid-x text-white"> <svg viewBox="0 0 2880 480" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2160 0C1440 240 720 240 720 240H0v240h2880V0h-720z" fill="currentColor" /> </svg></div></div></a> <a class="card-body" href="/blog/news/platformio-oss-july-2022-updates.html"><h3> PlatformIO Open Source July Updates</h3><p class="mb-0 text-muted"> PlatformIO Core 6.1, New boards & dev-kits, Support for the latest Arduino ESP32 core v2.0.4 and Teensyduino v1.57</p></a> <a class="card-meta mt-auto" href="/blog/news/platformio-oss-july-2022-updates.html"><hr class="card-meta-divider"><div class="avatar avatar-sm me-2"> <img src="/assets/img/avatars/vkoval.jpg" alt="Valerii Koval" class="avatar-img rounded-circle"></div><h6 class="text-uppercase text-muted me-2 mb-0"> Valerii Koval</h6><p class="h6 text-uppercase text-muted mb-0 ms-auto"> <time datetime="2022-08-01T00:00:00+03:00">Aug 01</time></p></a></div></div><div class="col-12 col-md-6 col-lg-4 d-flex"><div class="card mb-6 shadow-light-lg lift lift-lg"> <a class="card-img-top" href="/blog/news/platformio-core-5-1-released.html"> <img src="/assets/posts/2021-01-28-platformio-core-5-1-released/platformio-core-5-1-released.png" alt="PlatformIO Core 5.1 🚀" class="card-img-top"><div class="position-relative"><div class="shape shape-bottom shape-fluid-x text-white"> <svg viewBox="0 0 2880 480" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2160 0C1440 240 720 240 720 240H0v240h2880V0h-720z" fill="currentColor" /> </svg></div></div></a> <a class="card-body" href="/blog/news/platformio-core-5-1-released.html"><h3> PlatformIO Core 5.1 🚀</h3><p class="mb-0 text-muted"> PlatformIO Core 5.1 is out with boosted PlatformIO Home performance, support for SCons 4.1, and improved package management system</p></a> <a class="card-meta mt-auto" href="/blog/news/platformio-core-5-1-released.html"><hr class="card-meta-divider"><div class="avatar avatar-sm me-2"> <img src="/assets/img/avatars/ikravets.jpg" alt="Ivan Kravets" class="avatar-img rounded-circle"></div><h6 class="text-uppercase text-muted me-2 mb-0"> Ivan Kravets</h6><p class="h6 text-uppercase text-muted mb-0 ms-auto"> <time datetime="2021-01-28T00:00:00+02:00">Jan 28</time></p></a></div></div><div class="col-12 col-md-6 col-lg-4 d-flex"><div class="card mb-6 shadow-light-lg lift lift-lg"> <a class="card-img-top" href="/blog/news/microsoft-leverages-platformio.html"> <img src="/assets/posts/2021-09-06-microsoft-leverages-platformio/iot-for-beginners-logo.png" alt="Microsoft leverages PlatformIO for its course &quot;IoT for Beginners&quot;" class="card-img-top"><div class="position-relative"><div class="shape shape-bottom shape-fluid-x text-white"> <svg viewBox="0 0 2880 480" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2160 0C1440 240 720 240 720 240H0v240h2880V0h-720z" fill="currentColor" /> </svg></div></div></a> <a class="card-body" href="/blog/news/microsoft-leverages-platformio.html"><h3> Microsoft leverages PlatformIO for its course "IoT for Beginners"</h3><p class="mb-0 text-muted"> Learn the Internet of things in a 24-lesson curriculum designed for teachers, students and learners of all types who want to explore IoT with VS Code and PlatformIO</p></a> <a class="card-meta mt-auto" href="/blog/news/microsoft-leverages-platformio.html"><hr class="card-meta-divider"><div class="avatar avatar-sm me-2"> <img src="/assets/img/avatars/jbennett.jpg" alt="Jim Bennett" class="avatar-img rounded-circle"></div><h6 class="text-uppercase text-muted me-2 mb-0"> Jim Bennett</h6><p class="h6 text-uppercase text-muted mb-0 ms-auto"> <time datetime="2021-09-06T00:00:00+03:00">Sep 06</time></p></a></div></div></div></div></section></div><div class="position-relative"><div class="shape shape-bottom shape-fluid-x text-dark"> <svg viewBox="0 0 2880 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 48h2880V0h-720C1442.5 52 720 0 720 0H0v48z" fill="currentColor"/></svg></div></div><section class="bg-dark "><footer class="py-8 py-md-11 bg-dark border-gray-800-50 "><div class="container"><div class="row"><div class="col-12 col-md-6 col-lg-4"> <a href="/"><img src="/assets/img/platformio-labs-logo-horizontal-white.png" alt="PlatformIO Labs" class="img-fluid mb-2 mw-lg-75"></a><p class="text-gray-400 mb-2"> Make embedded developers and teams happy.</p><ul class="list-unstyled list-inline list-social mb-2"><li class="list-inline-item list-social-item me-3"> <a href="https://www.linkedin.com/company/platformio/" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/linkedin.svg" class="list-social-icon" alt="Follow on LinkedIn" title="Follow on LinkedIn"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://twitter.com/PlatformIO_Org" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/twitter.svg" class="list-social-icon" alt="Follow on Twitter" title="Follow on Twitter"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://www.facebook.com/platformio" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/facebook.svg" class="list-social-icon" alt="Follow on Facebook" title="Follow on Facebook"> </a></li><li class="list-inline-item list-social-item me-3"> <a href="https://github.com/platformio" class="text-decoration-none" target="_blank"> <img src="/assets/img/icons/social/github.svg" class="list-social-icon" alt="Follow on Github" title="Follow on Github"> </a></li></ul><p class="mb-6 mb-md-2 text-gray-600"> <small>© 2014-2024 PlatformIO Labs.</small></p></div><div class="col-12 col-md-6 col-lg-2"><h6 class="text-uppercase text-gray-400"> Company</h6><ul class="list-unstyled text-muted mb-6 mb-md-8 mb-lg-0"><li class="mb-3"> <a href="/" class="text-reset"> Home </a></li><li class="mb-3"> <a href="/company/about.html" class="text-reset"> About Us </a></li><li class="mb-3"> <a href="/blog/" class="text-reset"> Blog </a></li><li class="mb-3"> <a href="/#contact-us" class="text-reset"> Contact Us </a></li></ul></div><div class="col-12 col-md-6 col-lg-3"><h6 class="text-uppercase text-gray-400"> Technology</h6><ul class="list-unstyled text-muted mb-6 mb-md-8 mb-lg-0"><li class="mb-3"> <a href="/technology/next-generation-ide-framework.html" class="text-reset"> Next-Gen IDE Framework </a></li><li class="mb-3"> <a href="/technology/modern-ui-toolkit.html" class="text-reset"> Modern UI Toolkit </a></li><li class="mb-3"> <a href="/technology/trusted-package-registry.html" class="text-reset"> Trusted Package Registry </a></li><li> <a href="https://platformio.org/" class="text-reset"> PlatformIO Open Source </a></li></ul></div><div class="col-12 col-md-6 col-lg-3"><h6 class="text-uppercase text-gray-400"> Legal</h6><ul class="list-unstyled text-muted mb-0"><li class="mb-3"> <a href="/legal/code-of-conduct.html" class="text-reset"> Code of Conduct </a></li><li class="mb-3"> <a href="/legal/privacy.html" class="text-reset"> Privacy Policy </a></li><li class="mb-3"> <a href="/legal/terms-of-use.html" class="text-reset"> Terms of Use </a></li><li class="mb-3"> <a href="/legal/trademarks.html" class="text-reset"> Trademarks </a></li></ul></div></div></div></footer></section><script src="/assets/js/vendor.bundle.js?v=4"></script> <script src="/assets/js/theme.bundle.js?v=4"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-CNM31GXX7Y"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-CNM31GXX7Y'); </script></body></html>
